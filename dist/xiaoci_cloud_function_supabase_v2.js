// Â∞èÁì∑ËøûÁΩë - ‰∫ëÂáΩÊï∞ÊúçÂä°ÔºàSupabase ÂÖçË¥πÁâà - ‰ΩøÁî®axiosÔºâ
const https = require('https');

// ========== ÈÖçÁΩÆÂå∫ ==========
const CONFIG = {
    latestVersion: "1.0.0",
    releaseDate: "2025-10-03",
    downloadUrl: "https://github.com/‰Ω†ÁöÑÁî®Êà∑Âêç/‰ªìÂ∫ìÂêç/releases/download/v1.0.0/Â∞èÁì∑ËøûÁΩë.exe",
    downloadSize: "5.6 MB",
    updateLog: "„Äêv1.0.0 Ê≠£ÂºèÁâà„Äë\n‚ú® È¶ñ‰∏™Ê≠£ÂºèÂèëÂ∏ÉÁâàÊú¨\nüé® Á≤æÁæéÁöÑÂ∞èÁì∑È£éÊ†ºÁïåÈù¢\nüöÄ Ëá™Âä®ËøûÊé•Ê†°Âõ≠ÁΩë\nüìä ÂåøÂêç‰ΩøÁî®ÁªüËÆ°\nüîÑ Âú®Á∫øÁâàÊú¨Êõ¥Êñ∞",
    forceUpdate: false,
};

// ========== Supabase ÈÖçÁΩÆ ==========
const SUPABASE_URL = "https://hehlypeyunpjmvmzuaqg.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhlaGx5cGV5dW5wam12bXp1YXFnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTk0ODUwNTYsImV4cCI6MjA3NTA2MTA1Nn0.yYR06J8KEe2Kg-ab3ZgDLT87SLy058Hojx5lvwOQBSk";

// ËæÖÂä©ÂáΩÊï∞ÔºöÂèëÈÄÅHTTPSËØ∑Ê±Ç
function httpsRequest(url, options = {}) {
    return new Promise((resolve, reject) => {
        const urlObj = new URL(url);
        const reqOptions = {
            hostname: urlObj.hostname,
            path: urlObj.pathname + urlObj.search,
            method: options.method || 'GET',
            headers: options.headers || {},
        };

        const req = https.request(reqOptions, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                if (res.statusCode >= 200 && res.statusCode < 300) {
                    try {
                        resolve({ 
                            ok: true, 
                            data: JSON.parse(data), 
                            headers: res.headers,
                            statusCode: res.statusCode
                        });
                    } catch {
                        resolve({ ok: true, data: data, headers: res.headers, statusCode: res.statusCode });
                    }
                } else {
                    reject(new Error(`HTTP ${res.statusCode}: ${data}`));
                }
            });
        });

        req.on('error', reject);
        if (options.body) {
            req.write(options.body);
        }
        req.end();
    });
}

// ========== ‰∏ªÂáΩÊï∞ ==========
exports.main_handler = async (event, context) => {
    console.log("Êî∂Âà∞ËØ∑Ê±Ç:", event.path, event.httpMethod);
    
    const path = event.path || '/';
    const method = event.httpMethod || 'GET';
    
    const headers = {
        'Content-Type': 'application/json; charset=utf-8',
        'Access-Control-Allow-Origin': '*',
        'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
        'Access-Control-Allow-Headers': 'Content-Type',
    };
    
    try {
        // ===== ÁªüËÆ°Êé•Âè£ =====
        if (path === '/stats' && method === 'POST') {
            const body = JSON.parse(event.body || '{}');
            const deviceId = body.id || 'unknown';
            const version = body.v || '0.0.0';
            const os = body.os || 'Unknown';
            const now = new Date().toISOString();
            
            // Ê£ÄÊü•Áî®Êà∑ÊòØÂê¶Â≠òÂú®
            const checkResult = await httpsRequest(
                `${SUPABASE_URL}/rest/v1/users?device_id=eq.${deviceId}`,
                {
                    method: 'GET',
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`,
                    }
                }
            );
            
            const existingUsers = checkResult.data;
            
            if (existingUsers && existingUsers.length > 0) {
                // Êõ¥Êñ∞Áé∞ÊúâÁî®Êà∑
                const user = existingUsers[0];
                await httpsRequest(
                    `${SUPABASE_URL}/rest/v1/users?device_id=eq.${deviceId}`,
                    {
                        method: 'PATCH',
                        headers: {
                            'apikey': SUPABASE_KEY,
                            'Authorization': `Bearer ${SUPABASE_KEY}`,
                            'Content-Type': 'application/json',
                            'Prefer': 'return=minimal'
                        },
                        body: JSON.stringify({
                            last_seen: now,
                            version: version,
                            os: os,
                            launch_count: (user.launch_count || 0) + 1
                        })
                    }
                );
            } else {
                // ÂàõÂª∫Êñ∞Áî®Êà∑
                await httpsRequest(
                    `${SUPABASE_URL}/rest/v1/users`,
                    {
                        method: 'POST',
                        headers: {
                            'apikey': SUPABASE_KEY,
                            'Authorization': `Bearer ${SUPABASE_KEY}`,
                            'Content-Type': 'application/json',
                            'Prefer': 'return=minimal'
                        },
                        body: JSON.stringify({
                            device_id: deviceId,
                            first_seen: now,
                            last_seen: now,
                            version: version,
                            os: os,
                            launch_count: 1
                        })
                    }
                );
            }
            
            // ËÆ∞ÂΩïÂêØÂä®ÂéÜÂè≤
            await httpsRequest(
                `${SUPABASE_URL}/rest/v1/launches`,
                {
                    method: 'POST',
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`,
                        'Content-Type': 'application/json',
                        'Prefer': 'return=minimal'
                    },
                    body: JSON.stringify({
                        device_id: deviceId,
                        version: version,
                        timestamp: now,
                        os: os
                    })
                }
            );
            
            console.log(`ÁªüËÆ°ËÆ∞ÂΩï: ${deviceId} (v${version})`);
            
            return {
                statusCode: 200,
                headers: headers,
                body: JSON.stringify({ success: true })
            };
        }
        
        // ===== ÁâàÊú¨Ê£ÄÊü•Êé•Âè£ =====
        if (path === '/version' && method === 'GET') {
            return {
                statusCode: 200,
                headers: headers,
                body: JSON.stringify(CONFIG)
            };
        }
        
        // ===== ÁªüËÆ°Êï∞ÊçÆÊü•ËØ¢Êé•Âè£ =====
        if (path === '/dashboard' && method === 'GET') {
            const now = new Date();
            const oneDayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000).toISOString();
            const sevenDaysAgo = new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000).toISOString();
            const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000).toISOString();
            
            // Ëé∑ÂèñÊâÄÊúâÁî®Êà∑
            const usersResult = await httpsRequest(
                `${SUPABASE_URL}/rest/v1/users?select=*`,
                {
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`,
                    }
                }
            );
            
            const users = usersResult.data || [];
            
            // Ëé∑ÂèñÊâÄÊúâÂêØÂä®ËÆ∞ÂΩï
            const launchesResult = await httpsRequest(
                `${SUPABASE_URL}/rest/v1/launches?select=count`,
                {
                    method: 'GET',
                    headers: {
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`,
                        'Prefer': 'count=exact'
                    }
                }
            );
            
            // ‰ªéÂìçÂ∫îÂ§¥Ëé∑ÂèñÊÄªÊï∞
            const contentRange = launchesResult.headers['content-range'];
            const totalLaunches = contentRange ? parseInt(contentRange.split('/')[1] || 0) : users.reduce((sum, u) => sum + (u.launch_count || 0), 0);
            
            // ËÆ°ÁÆóÊ¥ªË∑ÉÁî®Êà∑
            const oneDayAgoTime = new Date(oneDayAgo).getTime();
            const sevenDaysAgoTime = new Date(sevenDaysAgo).getTime();
            const thirtyDaysAgoTime = new Date(thirtyDaysAgo).getTime();
            
            let dau = 0, wau = 0, mau = 0;
            const versionDistribution = {};
            
            users.forEach(user => {
                const lastSeenTime = new Date(user.last_seen).getTime();
                if (lastSeenTime >= oneDayAgoTime) dau++;
                if (lastSeenTime >= sevenDaysAgoTime) wau++;
                if (lastSeenTime >= thirtyDaysAgoTime) mau++;
                
                const v = user.version || '0.0.0';
                versionDistribution[v] = (versionDistribution[v] || 0) + 1;
            });
            
            const result = {
                totalUsers: users.length,
                totalLaunches: totalLaunches,
                dau: dau,
                wau: wau,
                mau: mau,
                versionDistribution: versionDistribution,
                latestVersion: CONFIG.latestVersion,
                updateTime: now.toISOString()
            };
            
            console.log("ÁªüËÆ°Êï∞ÊçÆ:", result);
            
            return {
                statusCode: 200,
                headers: headers,
                body: JSON.stringify(result)
            };
        }
        
        // ===== ÈªòËÆ§Êé•Âè£ =====
        return {
            statusCode: 200,
            headers: {
                'Content-Type': 'text/plain; charset=utf-8',
                'Access-Control-Allow-Origin': '*'
            },
            body: 'Â∞èÁì∑ËøûÁΩë‰∫ëÊúçÂä°ËøêË°å‰∏≠ÔºàSupabaseÂÖçË¥πÁâà v2Ôºâ‚úì'
        };
        
    } catch (error) {
        console.error("Â§ÑÁêÜÈîôËØØ:", error);
        return {
            statusCode: 500,
            headers: headers,
            body: JSON.stringify({ 
                error: error.message,
                stack: error.stack 
            })
        };
    }
};

